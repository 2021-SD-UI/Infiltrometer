[{"E:\\Infiltrometer\\infiltrometer21\\src\\index.js":"1","E:\\Infiltrometer\\infiltrometer21\\src\\App.js":"2","E:\\Infiltrometer\\infiltrometer21\\src\\serviceWorker.js":"3","E:\\Infiltrometer\\infiltrometer21\\src\\app\\store.js":"4","E:\\Infiltrometer\\infiltrometer21\\src\\features\\baer-initialize\\BaerInitializeView.js":"5","E:\\Infiltrometer\\infiltrometer21\\src\\features\\baer-initialize\\bear-initializeSlice.js":"6","E:\\Infiltrometer\\infiltrometer21\\src\\features\\baer-replication\\BaerReplicationView.js":"7","E:\\Infiltrometer\\infiltrometer21\\src\\features\\counter\\Counter.js":"8","E:\\Infiltrometer\\infiltrometer21\\src\\features\\counter\\counterSlice.js":"9","E:\\Infiltrometer\\infiltrometer21\\src\\features\\baer-results\\bear-resultsSlice.js":"10","E:\\Infiltrometer\\infiltrometer21\\src\\features\\baer-results\\BaerResultsView.js":"11","E:\\Infiltrometer\\infiltrometer21\\src\\features\\baer-replication\\bear-replicationSlice.js":"12","E:\\Infiltrometer\\infiltrometer21\\src\\features\\counter\\counterAPI.js":"13","E:\\Infiltrometer\\infiltrometer21\\src\\features\\reports\\reportsSlice.js":"14","E:\\Infiltrometer\\infiltrometer21\\src\\features\\reports\\ShowReportsButon.js":"15","E:\\Infiltrometer\\infiltrometer21\\src\\features\\reports\\protocols.js":"16","E:\\Infiltrometer\\infiltrometer21\\src\\features\\regression\\RegressionTesting.js":"17","E:\\Infiltrometer\\infiltrometer21\\src\\features\\regression\\regression-js.js":"18"},{"size":661,"mtime":1631964288211,"results":"19","hashOfConfig":"20"},{"size":1407,"mtime":1632006991999,"results":"21","hashOfConfig":"20"},{"size":5151,"mtime":1631899423581,"results":"22","hashOfConfig":"20"},{"size":684,"mtime":1631962504517,"results":"23","hashOfConfig":"20"},{"size":881,"mtime":1631965785797,"results":"24","hashOfConfig":"20"},{"size":346,"mtime":1631962504561,"results":"25","hashOfConfig":"20"},{"size":365,"mtime":1631962504575,"results":"26","hashOfConfig":"20"},{"size":1826,"mtime":1631837654030,"results":"27","hashOfConfig":"28"},{"size":2819,"mtime":1631899423578,"results":"29","hashOfConfig":"20"},{"size":335,"mtime":1631962504591,"results":"30","hashOfConfig":"20"},{"size":361,"mtime":1631964644219,"results":"31","hashOfConfig":"20"},{"size":396,"mtime":1632006921300,"results":"32","hashOfConfig":"20"},{"size":202,"mtime":1631899423578,"results":"33","hashOfConfig":"20"},{"size":1017,"mtime":1631965687248,"results":"34","hashOfConfig":"20"},{"size":504,"mtime":1631964263984,"results":"35","hashOfConfig":"20"},{"size":175,"mtime":1631965019821,"results":"36","hashOfConfig":"20"},{"size":1085,"mtime":1632005081692,"results":"37","hashOfConfig":"20"},{"size":9271,"mtime":1632005979115,"results":"38","hashOfConfig":"20"},{"filePath":"39","messages":"40","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"18tp1z2",{"filePath":"41","messages":"42","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"43","messages":"44","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"45","messages":"46","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"47","messages":"48","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"49","messages":"50","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"51"},{"filePath":"52","messages":"53","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"54","messages":"55","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"56"},"c42c6c",{"filePath":"57","messages":"58","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"59","messages":"60","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"61"},{"filePath":"62","messages":"63","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"64","messages":"65","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"66"},{"filePath":"67","messages":"68","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"69","messages":"70","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"71"},{"filePath":"72","messages":"73","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"74"},{"filePath":"75","messages":"76","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"77","messages":"78","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"79","messages":"80","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"81"},"E:\\Infiltrometer\\infiltrometer21\\src\\index.js",[],"E:\\Infiltrometer\\infiltrometer21\\src\\App.js",[],"E:\\Infiltrometer\\infiltrometer21\\src\\serviceWorker.js",[],"E:\\Infiltrometer\\infiltrometer21\\src\\app\\store.js",[],"E:\\Infiltrometer\\infiltrometer21\\src\\features\\baer-initialize\\BaerInitializeView.js",[],"E:\\Infiltrometer\\infiltrometer21\\src\\features\\baer-initialize\\bear-initializeSlice.js",["82"],"import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';\r\n\r\n\r\nconst initialState = {};\r\n\r\nexport const baerInitializeSlice = createSlice({\r\n    name: 'baerInitialize',\r\n  initialState,\r\n  // The `reducers` field lets us define reducers and generate associated actions\r\n  reducers: {\r\n  }\r\n});\r\nexport default baerInitializeSlice.reducer;","E:\\Infiltrometer\\infiltrometer21\\src\\features\\baer-replication\\BaerReplicationView.js",[],"E:\\Infiltrometer\\infiltrometer21\\src\\features\\counter\\Counter.js",[],["83","84"],"E:\\Infiltrometer\\infiltrometer21\\src\\features\\counter\\counterSlice.js",[],"E:\\Infiltrometer\\infiltrometer21\\src\\features\\baer-results\\bear-resultsSlice.js",["85"],"import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';\r\n\r\n\r\n\r\nconst initialState = {};\r\n\r\nexport const baerResultsSlice = createSlice({\r\n    name: 'baerResults',\r\n  initialState,\r\n  // The `reducers` field lets us define reducers and generate associated actions\r\n  reducers: {}\r\n});\r\nexport default baerResultsSlice.reducer;","E:\\Infiltrometer\\infiltrometer21\\src\\features\\baer-results\\BaerResultsView.js",[],"E:\\Infiltrometer\\infiltrometer21\\src\\features\\baer-replication\\bear-replicationSlice.js",["86","87"],"import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';\r\nimport {TimerStateValues} from 'react-compound-timer'\r\nconst initialState = {};\r\n\r\nexport const baerReplicationSlice = createSlice({\r\n    name: 'baerReplication',\r\n  initialState,\r\n  // The `reducers` field lets us define reducers and generate associated actions\r\n  reducers: {}\r\n});\r\nexport default baerReplicationSlice.reducer;","E:\\Infiltrometer\\infiltrometer21\\src\\features\\counter\\counterAPI.js",[],"E:\\Infiltrometer\\infiltrometer21\\src\\features\\reports\\reportsSlice.js",["88"],"import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';\r\n\r\n\r\n\r\n\r\n//empty array of reports\r\nconst initialState = {\r\n    reports:[],\r\n    curId: 0\r\n};\r\n\r\nexport const reportsSlice = createSlice({\r\n  name: 'baerResults',\r\n  initialState,\r\n  // The `reducers` field lets us define reducers and generate associated actions\r\n  reducers: {\r\n     newReport: (state, action) => {\r\n      // Push a new report onto the report stack and increment the id\r\n      state.reports.push(\r\n        {\r\n            id: state.curId++,\r\n            date: action.payload.date,\r\n            protocol: action.payload.protocol,\r\n            readings: [],\r\n            infiltrometerType: action.payload.infiltrometerType\r\n        }\r\n      );\r\n\r\n    },\r\n    addReading: (state, action)=>{\r\n        state.reports[action.payload.id].readings.push(action.payload.reading); \r\n    }\r\n  }\r\n});\r\n\r\nexport const { newReport } = reportsSlice.actions;\r\nexport const selectReports = (state) => state.reports;\r\n\r\nexport default reportsSlice.reducer;","E:\\Infiltrometer\\infiltrometer21\\src\\features\\reports\\ShowReportsButon.js",["89","90","91"],"import React, { useState } from 'react';\r\nimport { useSelector, useDispatch } from 'react-redux';\r\nimport {selectReports\r\n} from './reportsSlice';\r\n\r\nlet reports;\r\nfunction PrintReports(){\r\n  reports = useSelector(selectReports)\r\n  console.log(reports);\r\n}\r\n\r\nexport function ShowReportsButton() {\r\n    const reports = useSelector(selectReports);\r\n\r\n    return(\r\n    <div>\r\n        <button onClick={()=>console.log(reports)}>\r\n            Show Reports in Store\r\n        </button>\r\n    </div>\r\n\r\n  );\r\n\r\n}","E:\\Infiltrometer\\infiltrometer21\\src\\features\\reports\\protocols.js",[],"E:\\Infiltrometer\\infiltrometer21\\src\\features\\regression\\RegressionTesting.js",[],"E:\\Infiltrometer\\infiltrometer21\\src\\features\\regression\\regression-js.js",["92"],"const DEFAULT_OPTIONS = { order: 2, precision: 2, period: null };\r\n\r\n/**\r\n* Determine the coefficient of determination (r^2) of a fit from the observations\r\n* and predictions.\r\n*\r\n* @param {Array<Array<number>>} data - Pairs of observed x-y values\r\n* @param {Array<Array<number>>} results - Pairs of observed predicted x-y values\r\n*\r\n* @return {number} - The r^2 value, or NaN if one cannot be calculated.\r\n*/\r\nfunction determinationCoefficient(data, results) {\r\n  const predictions = [];\r\n  const observations = [];\r\n\r\n  data.forEach((d, i) => {\r\n    if (d[1] !== null) {\r\n      observations.push(d);\r\n      predictions.push(results[i]);\r\n    }\r\n  });\r\n\r\n  const sum = observations.reduce((a, observation) => a + observation[1], 0);\r\n  const mean = sum / observations.length;\r\n\r\n  const ssyy = observations.reduce((a, observation) => {\r\n    const difference = observation[1] - mean;\r\n    return a + (difference * difference);\r\n  }, 0);\r\n\r\n  const sse = observations.reduce((accum, observation, index) => {\r\n    const prediction = predictions[index];\r\n    const residual = observation[1] - prediction[1];\r\n    return accum + (residual * residual);\r\n  }, 0);\r\n\r\n  return 1 - (sse / ssyy);\r\n}\r\n\r\n/**\r\n* Determine the solution of a system of linear equations A * x = b using\r\n* Gaussian elimination.\r\n*\r\n* @param {Array<Array<number>>} input - A 2-d matrix of data in row-major form [ A | b ]\r\n* @param {number} order - How many degrees to solve for\r\n*\r\n* @return {Array<number>} - Vector of normalized solution coefficients matrix (x)\r\n*/\r\nfunction gaussianElimination(input, order) {\r\n  const matrix = input;\r\n  const n = input.length - 1;\r\n  const coefficients = [order];\r\n\r\n  for (let i = 0; i < n; i++) {\r\n    let maxrow = i;\r\n    for (let j = i + 1; j < n; j++) {\r\n      if (Math.abs(matrix[i][j]) > Math.abs(matrix[i][maxrow])) {\r\n        maxrow = j;\r\n      }\r\n    }\r\n\r\n    for (let k = i; k < n + 1; k++) {\r\n      const tmp = matrix[k][i];\r\n      matrix[k][i] = matrix[k][maxrow];\r\n      matrix[k][maxrow] = tmp;\r\n    }\r\n\r\n    for (let j = i + 1; j < n; j++) {\r\n      for (let k = n; k >= i; k--) {\r\n        matrix[k][j] -= (matrix[k][i] * matrix[i][j]) / matrix[i][i];\r\n      }\r\n    }\r\n  }\r\n\r\n  for (let j = n - 1; j >= 0; j--) {\r\n    let total = 0;\r\n    for (let k = j + 1; k < n; k++) {\r\n      total += matrix[k][j] * coefficients[k];\r\n    }\r\n\r\n    coefficients[j] = (matrix[n][j] - total) / matrix[j][j];\r\n  }\r\n\r\n  return coefficients;\r\n}\r\n\r\n/**\r\n* Round a number to a precision, specificed in number of decimal places\r\n*\r\n* @param {number} number - The number to round\r\n* @param {number} precision - The number of decimal places to round to:\r\n*                             > 0 means decimals, < 0 means powers of 10\r\n*\r\n*\r\n* @return {numbr} - The number, rounded\r\n*/\r\nfunction round(number, precision) {\r\n  const factor = 10 ** precision;\r\n  return Math.round(number * factor) / factor;\r\n}\r\n\r\n/**\r\n* The set of all fitting methods\r\n*\r\n* @namespace\r\n*/\r\nexport const methods = {\r\n  linear(data, options) {\r\n    const sum = [0, 0, 0, 0, 0];\r\n    let len = 0;\r\n\r\n    for (let n = 0; n < data.length; n++) {\r\n      if (data[n][1] !== null) {\r\n        len++;\r\n        sum[0] += data[n][0];\r\n        sum[1] += data[n][1];\r\n        sum[2] += data[n][0] * data[n][0];\r\n        sum[3] += data[n][0] * data[n][1];\r\n        sum[4] += data[n][1] * data[n][1];\r\n      }\r\n    }\r\n\r\n    const run = ((len * sum[2]) - (sum[0] * sum[0]));\r\n    const rise = ((len * sum[3]) - (sum[0] * sum[1]));\r\n    const gradient = run === 0 ? 0 : round(rise / run, options.precision);\r\n    const intercept = round((sum[1] / len) - ((gradient * sum[0]) / len), options.precision);\r\n\r\n    const predict = x => ([\r\n      round(x, options.precision),\r\n      round((gradient * x) + intercept, options.precision)]\r\n    );\r\n\r\n    const points = data.map(point => predict(point[0]));\r\n\r\n    return {\r\n      points,\r\n      predict,\r\n      equation: [gradient, intercept],\r\n      r2: round(determinationCoefficient(data, points), options.precision),\r\n      string: intercept === 0 ? `y = ${gradient}x` : `y = ${gradient}x + ${intercept}`,\r\n    };\r\n  },\r\n\r\n  exponential(data, options) {\r\n    const sum = [0, 0, 0, 0, 0, 0];\r\n\r\n    for (let n = 0; n < data.length; n++) {\r\n      if (data[n][1] !== null) {\r\n        sum[0] += data[n][0];\r\n        sum[1] += data[n][1];\r\n        sum[2] += data[n][0] * data[n][0] * data[n][1];\r\n        sum[3] += data[n][1] * Math.log(data[n][1]);\r\n        sum[4] += data[n][0] * data[n][1] * Math.log(data[n][1]);\r\n        sum[5] += data[n][0] * data[n][1];\r\n      }\r\n    }\r\n\r\n    const denominator = ((sum[1] * sum[2]) - (sum[5] * sum[5]));\r\n    const a = Math.exp(((sum[2] * sum[3]) - (sum[5] * sum[4])) / denominator);\r\n    const b = ((sum[1] * sum[4]) - (sum[5] * sum[3])) / denominator;\r\n    const coeffA = round(a, options.precision);\r\n    const coeffB = round(b, options.precision);\r\n    const predict = x => ([\r\n      round(x, options.precision),\r\n      round(coeffA * Math.exp(coeffB * x), options.precision),\r\n    ]);\r\n\r\n    const points = data.map(point => predict(point[0]));\r\n\r\n    return {\r\n      points,\r\n      predict,\r\n      equation: [coeffA, coeffB],\r\n      string: `y = ${coeffA}e^(${coeffB}x)`,\r\n      r2: round(determinationCoefficient(data, points), options.precision),\r\n    };\r\n  },\r\n\r\n  logarithmic(data, options) {\r\n    const sum = [0, 0, 0, 0];\r\n    const len = data.length;\r\n\r\n    for (let n = 0; n < len; n++) {\r\n      if (data[n][1] !== null) {\r\n        sum[0] += Math.log(data[n][0]);\r\n        sum[1] += data[n][1] * Math.log(data[n][0]);\r\n        sum[2] += data[n][1];\r\n        sum[3] += (Math.log(data[n][0]) ** 2);\r\n      }\r\n    }\r\n\r\n    const a = ((len * sum[1]) - (sum[2] * sum[0])) / ((len * sum[3]) - (sum[0] * sum[0]));\r\n    const coeffB = round(a, options.precision);\r\n    const coeffA = round((sum[2] - (coeffB * sum[0])) / len, options.precision);\r\n\r\n    const predict = x => ([\r\n      round(x, options.precision),\r\n      round(round(coeffA + (coeffB * Math.log(x)), options.precision), options.precision),\r\n    ]);\r\n\r\n    const points = data.map(point => predict(point[0]));\r\n\r\n    return {\r\n      points,\r\n      predict,\r\n      equation: [coeffA, coeffB],\r\n      string: `y = ${coeffA} + ${coeffB} ln(x)`,\r\n      r2: round(determinationCoefficient(data, points), options.precision),\r\n    };\r\n  },\r\n\r\n  power(data, options) {\r\n    const sum = [0, 0, 0, 0, 0];\r\n    const len = data.length;\r\n\r\n    for (let n = 0; n < len; n++) {\r\n      if (data[n][1] !== null) {\r\n        sum[0] += Math.log(data[n][0]);\r\n        sum[1] += Math.log(data[n][1]) * Math.log(data[n][0]);\r\n        sum[2] += Math.log(data[n][1]);\r\n        sum[3] += (Math.log(data[n][0]) ** 2);\r\n      }\r\n    }\r\n\r\n    const b = ((len * sum[1]) - (sum[0] * sum[2])) / ((len * sum[3]) - (sum[0] ** 2));\r\n    const a = ((sum[2] - (b * sum[0])) / len);\r\n    const coeffA = round(Math.exp(a), options.precision);\r\n    const coeffB = round(b, options.precision);\r\n\r\n    const predict = x => ([\r\n      round(x, options.precision),\r\n      round(round(coeffA * (x ** coeffB), options.precision), options.precision),\r\n    ]);\r\n\r\n    const points = data.map(point => predict(point[0]));\r\n\r\n    return {\r\n      points,\r\n      predict,\r\n      equation: [coeffA, coeffB],\r\n      string: `y = ${coeffA}x^${coeffB}`,\r\n      r2: round(determinationCoefficient(data, points), options.precision),\r\n    };\r\n  },\r\n\r\n  polynomial(data, options) {\r\n    const lhs = [];\r\n    const rhs = [];\r\n    let a = 0;\r\n    let b = 0;\r\n\r\n    const len = data.length;\r\n    const k = options.order + 1;\r\n\r\n    for (let i = 1; i < k; i++) {\r\n      for (let l = 0; l < len; l++) {\r\n        if (data[l][1] !== null) {\r\n          a += (data[l][0] ** i) * data[l][1];\r\n        }\r\n      }\r\n\r\n      lhs.push(a);\r\n      a = 0;\r\n\r\n      const c = [];\r\n      for (let j = 1; j < k; j++) {\r\n        for (let l = 0; l < len; l++) {\r\n          if (data[l][1] !== null) {\r\n            b += data[l][0] ** (i + j);\r\n          }\r\n        }\r\n        c.push(b);\r\n        b = 0;\r\n      }\r\n      rhs.push(c);\r\n    }\r\n    rhs.push(lhs);\r\n\r\n    const coefficients = [0,...gaussianElimination(rhs, k).map(v => round(v, options.precision))];\r\n    const predict = x => ([\r\n      round(x, options.precision),\r\n      round(\r\n        coefficients.reduce((sum, coeff, power) => sum + (coeff * (x ** power)), 0),\r\n        options.precision,\r\n      ),\r\n    ]);\r\n\r\n    const points = data.map(point => predict(point[0]));\r\n\r\n    let string = 'y = ';\r\n    for (let i = coefficients.length - 1; i >= 0; i--) {\r\n      if (i > 1) {\r\n        string += `${coefficients[i]}x^${i} + `;\r\n      } else if (i === 1) {\r\n        string += `${coefficients[i]}x + `;\r\n      } else {\r\n        string += coefficients[i];\r\n      }\r\n    }\r\n\r\n    return {\r\n      string,\r\n      points,\r\n      predict,\r\n      equation: [...coefficients].reverse(),\r\n      r2: round(determinationCoefficient(data, points), options.precision),\r\n    };\r\n  },\r\n};\r\n\r\nfunction createWrapper() {\r\n  const reduce = (accumulator, name) => ({\r\n    _round: round,\r\n    ...accumulator,\r\n    [name](data, supplied) {\r\n      return methods[name](data, {\r\n        ...DEFAULT_OPTIONS,\r\n        ...supplied,\r\n      });\r\n    },\r\n  });\r\n\r\n  return Object.keys(methods).reduce(reduce, {});\r\n}\r\n",{"ruleId":"93","severity":1,"message":"94","line":1,"column":10,"nodeType":"95","messageId":"96","endLine":1,"endColumn":26},{"ruleId":"97","replacedBy":"98"},{"ruleId":"99","replacedBy":"100"},{"ruleId":"93","severity":1,"message":"94","line":1,"column":10,"nodeType":"95","messageId":"96","endLine":1,"endColumn":26},{"ruleId":"93","severity":1,"message":"94","line":1,"column":10,"nodeType":"95","messageId":"96","endLine":1,"endColumn":26},{"ruleId":"93","severity":1,"message":"101","line":2,"column":9,"nodeType":"95","messageId":"96","endLine":2,"endColumn":25},{"ruleId":"93","severity":1,"message":"94","line":1,"column":10,"nodeType":"95","messageId":"96","endLine":1,"endColumn":26},{"ruleId":"93","severity":1,"message":"102","line":1,"column":17,"nodeType":"95","messageId":"96","endLine":1,"endColumn":25},{"ruleId":"93","severity":1,"message":"103","line":2,"column":23,"nodeType":"95","messageId":"96","endLine":2,"endColumn":34},{"ruleId":"93","severity":1,"message":"104","line":7,"column":10,"nodeType":"95","messageId":"96","endLine":7,"endColumn":22},{"ruleId":"93","severity":1,"message":"105","line":311,"column":10,"nodeType":"95","messageId":"96","endLine":311,"endColumn":23},"no-unused-vars","'createAsyncThunk' is defined but never used.","Identifier","unusedVar","no-native-reassign",["106"],"no-negated-in-lhs",["107"],"'TimerStateValues' is defined but never used.","'useState' is defined but never used.","'useDispatch' is defined but never used.","'PrintReports' is defined but never used.","'createWrapper' is defined but never used.","no-global-assign","no-unsafe-negation"]