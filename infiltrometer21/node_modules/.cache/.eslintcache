[{"C:\\Users\\caboo\\OneDrive\\Documents\\GitHub\\Infiltrometer\\infiltrometer21\\src\\index.js":"1","C:\\Users\\caboo\\OneDrive\\Documents\\GitHub\\Infiltrometer\\infiltrometer21\\src\\App.js":"2","C:\\Users\\caboo\\OneDrive\\Documents\\GitHub\\Infiltrometer\\infiltrometer21\\src\\serviceWorker.js":"3","C:\\Users\\caboo\\OneDrive\\Documents\\GitHub\\Infiltrometer\\infiltrometer21\\src\\app\\store.js":"4","C:\\Users\\caboo\\OneDrive\\Documents\\GitHub\\Infiltrometer\\infiltrometer21\\src\\features\\baer-replication\\BaerReplicationView.js":"5","C:\\Users\\caboo\\OneDrive\\Documents\\GitHub\\Infiltrometer\\infiltrometer21\\src\\features\\baer-initialize\\bear-initializeSlice.js":"6","C:\\Users\\caboo\\OneDrive\\Documents\\GitHub\\Infiltrometer\\infiltrometer21\\src\\features\\baer-replication\\bear-replicationSlice.js":"7","C:\\Users\\caboo\\OneDrive\\Documents\\GitHub\\Infiltrometer\\infiltrometer21\\src\\features\\reports\\ShowReportsButon.js":"8","C:\\Users\\caboo\\OneDrive\\Documents\\GitHub\\Infiltrometer\\infiltrometer21\\src\\features\\baer-initialize\\BaerInitializeView.js":"9","C:\\Users\\caboo\\OneDrive\\Documents\\GitHub\\Infiltrometer\\infiltrometer21\\src\\features\\baer-results\\bear-resultsSlice.js":"10","C:\\Users\\caboo\\OneDrive\\Documents\\GitHub\\Infiltrometer\\infiltrometer21\\src\\features\\reports\\reportsSlice.js":"11","C:\\Users\\caboo\\OneDrive\\Documents\\GitHub\\Infiltrometer\\infiltrometer21\\src\\features\\regression\\RegressionTesting.js":"12","C:\\Users\\caboo\\OneDrive\\Documents\\GitHub\\Infiltrometer\\infiltrometer21\\src\\features\\baer-results\\BaerResultsView.js":"13","C:\\Users\\caboo\\OneDrive\\Documents\\GitHub\\Infiltrometer\\infiltrometer21\\src\\features\\counter\\counterSlice.js":"14","C:\\Users\\caboo\\OneDrive\\Documents\\GitHub\\Infiltrometer\\infiltrometer21\\src\\app\\soilTypes.js":"15","C:\\Users\\caboo\\OneDrive\\Documents\\GitHub\\Infiltrometer\\infiltrometer21\\src\\features\\reports\\protocols.js":"16","C:\\Users\\caboo\\OneDrive\\Documents\\GitHub\\Infiltrometer\\infiltrometer21\\src\\features\\counter\\counterAPI.js":"17","C:\\Users\\caboo\\OneDrive\\Documents\\GitHub\\Infiltrometer\\infiltrometer21\\src\\features\\regression\\regression-js.js":"18"},{"size":707,"mtime":1632591552516,"results":"19","hashOfConfig":"20"},{"size":1409,"mtime":1632591552511,"results":"21","hashOfConfig":"20"},{"size":5151,"mtime":1632591545509,"results":"22","hashOfConfig":"20"},{"size":684,"mtime":1632591545500,"results":"23","hashOfConfig":"20"},{"size":4157,"mtime":1632591552513,"results":"24","hashOfConfig":"20"},{"size":2244,"mtime":1632591552513,"results":"25","hashOfConfig":"20"},{"size":1182,"mtime":1632591552514,"results":"26","hashOfConfig":"20"},{"size":504,"mtime":1632591545507,"results":"27","hashOfConfig":"20"},{"size":6558,"mtime":1632591552512,"results":"28","hashOfConfig":"20"},{"size":393,"mtime":1632602610375,"results":"29","hashOfConfig":"20"},{"size":1323,"mtime":1632608172541,"results":"30","hashOfConfig":"20"},{"size":1085,"mtime":1632591545506,"results":"31","hashOfConfig":"20"},{"size":1926,"mtime":1632644299804,"results":"32","hashOfConfig":"20"},{"size":2819,"mtime":1632591545505,"results":"33","hashOfConfig":"20"},{"size":569,"mtime":1632591552512,"results":"34","hashOfConfig":"20"},{"size":175,"mtime":1632591545507,"results":"35","hashOfConfig":"20"},{"size":202,"mtime":1632591545504,"results":"36","hashOfConfig":"20"},{"size":9271,"mtime":1632591545506,"results":"37","hashOfConfig":"20"},{"filePath":"38","messages":"39","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},"1i4jf6k",{"filePath":"41","messages":"42","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"43","messages":"44","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"45","messages":"46","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"47","messages":"48","errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"49","usedDeprecatedRules":"40"},{"filePath":"50","messages":"51","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"52","usedDeprecatedRules":"40"},{"filePath":"53","messages":"54","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"55","messages":"56","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"57","usedDeprecatedRules":"40"},{"filePath":"58","messages":"59","errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"60","usedDeprecatedRules":"40"},{"filePath":"61","messages":"62","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"63","usedDeprecatedRules":"40"},{"filePath":"64","messages":"65","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"66","usedDeprecatedRules":"40"},{"filePath":"67","messages":"68","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"69","messages":"70","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"71","messages":"72","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"73","messages":"74","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"75","messages":"76","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"77","messages":"78","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"79","messages":"80","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"81","usedDeprecatedRules":"40"},"C:\\Users\\caboo\\OneDrive\\Documents\\GitHub\\Infiltrometer\\infiltrometer21\\src\\index.js",[],["82","83"],"C:\\Users\\caboo\\OneDrive\\Documents\\GitHub\\Infiltrometer\\infiltrometer21\\src\\App.js",[],"C:\\Users\\caboo\\OneDrive\\Documents\\GitHub\\Infiltrometer\\infiltrometer21\\src\\serviceWorker.js",[],"C:\\Users\\caboo\\OneDrive\\Documents\\GitHub\\Infiltrometer\\infiltrometer21\\src\\app\\store.js",[],"C:\\Users\\caboo\\OneDrive\\Documents\\GitHub\\Infiltrometer\\infiltrometer21\\src\\features\\baer-replication\\BaerReplicationView.js",["84","85","86","87","88"],"//The Page we are displaying for the baer Initialize view\r\nimport { Link } from 'react-router-dom';\r\nimport React, {useState} from 'react';\r\nimport ReactDOM from \"react-dom\";\r\nimport { useSelector, useDispatch } from 'react-redux';\r\nimport { setVolume, setSecondsElapsed, selectLastVolume, setLastVolume } from './bear-replicationSlice';\r\nimport {addReading} from '../reports/reportsSlice';\r\nimport { selectTimeInterval, selectInitialVolume, setSoilType, selectSoilType } from '../baer-initialize/bear-initializeSlice';\r\nimport {CountdownCircleTimer} from \"react-countdown-circle-timer\";\r\nimport \"./timer.css\";\r\nimport _default from 'react-overlays/esm/Modal';\r\nimport { useEffect } from 'react';\r\n\r\nconst renderTime = ({ remainingTime }) => {\r\n  if (remainingTime === 0) {\r\n    return <div className=\"timer\">Time is up!</div>;\r\n  }\r\n  return (\r\n      <div className=\"timer\">\r\n        <div className=\"text\">Time remaining:</div>\r\n        <div className=\"value\">{remainingTime}</div>\r\n        <div className=\"text\">seconds</div>\r\n      </div>\r\n  );\r\n};\r\n\r\nconst BaerReplicationView = () => {\r\n\r\n \r\n\r\n  //Gets the current reading in the baer-replicationSlice\r\n  const timeInterval = useSelector(selectTimeInterval);\r\n  const initialVolume = Number(useSelector(selectInitialVolume));\r\n  const lastVolume = Number(useSelector(selectLastVolume));\r\n\r\n  //the max allowed volume\r\n  const maxVolume = Math.min(initialVolume, lastVolume);\r\n\r\n  const dispatch = useDispatch();\r\n\r\n  //current soil type in the store\r\n  const curSoilType = useSelector(selectSoilType);\r\n\r\n   const initializeState = {\r\n    timerIsPlaying: false,\r\n    key: 0,\r\n  };\r\n  \r\n  \r\n  const [state, setState] = useState(initializeState);\r\n\r\n  //use to set the key variable\r\n  const setKey = (key) => setState({...state, key});\r\n  //use to set the timer is playing variable\r\n  const setPlaying = (playing)=>setState({...state, timerIsPlaying:playing});\r\n \r\n\r\n  // This function will be called when the timer reaches zero.\r\n  function getVolumeReading() {\r\n      let volumeReading = Number(prompt(\"Enter volumetric data below.\",0));\r\n\r\n      // Notify user of invalid input if volume reading is greater than last volume or is negative.\r\n      \r\n      while (volumeReading > maxVolume\r\n         || volumeReading < 0 || volumeReading == null) {\r\n          window.confirm(\"Invalid input! Make sure your volume reading is less than or equal to: \" + maxVolume );\r\n          volumeReading = Number(prompt(\"Enter volumetric data below.\",0));\r\n      }\r\n      // TODO: Record data to report\r\n\r\n          //TODO: set the volume in the replication store\r\n          dispatch(setLastVolume(volumeReading));\r\n          dispatch(setVolume(volumeReading));\r\n          dispatch(setSecondsElapsed(0));\r\n          dispatch(addReading(\r\n            \r\n            {volume: volumeReading, secondsElapsed: 0}\r\n            \r\n            ));\r\n          setKey(state.key + 1);\r\n      \r\n  }\r\n\r\n  return (\r\n      <div>\r\n        <div className=\"timer-wrapper\">\r\n          <CountdownCircleTimer\r\n              key={state.key}\r\n              isPlaying = {state.timerIsPlaying}\r\n              duration={Number(timeInterval)}\r\n              colors={[[\"#004777\", 0.33], [\"#F7B801\", 0.33], [\"#A30000\"]]}\r\n              onComplete={() => getVolumeReading()}\r\n          >\r\n            {renderTime}\r\n          </CountdownCircleTimer>\r\n        </div>\r\n          <div>\r\n            Last Volume: {maxVolume}\r\n          </div>\r\n        <div class=\"container\">\r\n          <div class=\"row\">\r\n             <button type=\"submit\" class=\"btn btn-primary col-md-10\" onClick = {()=>setPlaying(!state.timerIsPlaying)}>{\r\n            \r\n            !state.timerIsPlaying? \"Start \" : \"Stop \"\r\n            \r\n            } Timer</button>\r\n            <button type=\"submit\" class=\"btn btn-secondary col-md-10\">\r\n              End Protocol\r\n            </button>\r\n          </div>\r\n           \r\n        </div>\r\n        <Link to =\"/Infiltrometer/baer-results\">To Results View</Link>\r\n      </div>);\r\n}\r\n\r\n// const rootElement = document.getElementById(\"root\");\r\n// ReactDOM.render(<BaerReplicationView />, rootElement);\r\nexport default BaerReplicationView;","C:\\Users\\caboo\\OneDrive\\Documents\\GitHub\\Infiltrometer\\infiltrometer21\\src\\features\\baer-initialize\\bear-initializeSlice.js",["89"],"import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';\r\nimport { soilTypes } from '../../app/soilTypes';\r\n\r\n\r\n const initialState = {  \r\n        initialVolume: 0,\r\n        \r\n        coordinates: {\r\n          lat:0,\r\n          long: 0,\r\n        },\r\n\r\n        soilType: soilTypes.custom,\r\n        \r\n        infiltrometerRadius: 0,\r\n        \r\n        timeInterval: 30\r\n\r\n};\r\n\r\n\r\n\r\n/**\r\n * We need slices to \r\n */\r\nexport const baerInitializeSlice = createSlice({\r\n    name: 'baerInitialize',\r\n  initialState,\r\n  // The `reducers` field lets us define reducers and generate associated actions\r\n  reducers: {\r\n    //Update the appropritate values to the provided infiltrometer type  \r\n    \r\n    setInfiltrometerType: (state, action) => {\r\n      \r\n      switch (action.payload.infiltrometerType){\r\n        default:\r\n          //set the radius to 0\r\n          state.infiltrometerR = 0;\r\n          break;\r\n\r\n      }\r\n    },\r\n    setInitialVolume: (state, action)=>{\r\n\r\n      state.initialVolume = action.payload;\r\n    \r\n    },\r\n    setInfiltrometerSuction: (state, action)=>{\r\n      state.infiltrometerSuction = action.payload;\r\n    },\r\n    setTimeInterval: (state, action)=>{\r\n      state.timeInterval = action.payload;\r\n    },\r\n    setSoilType:(state, action)=>{\r\n      state.soilType = action.payload;\r\n    }\r\n\r\n  }\r\n});\r\n\r\n/**\r\n * A selector returning the current type of the infiltrometer\r\n * @param {*} state \r\n * @returns \r\n */\r\nexport const selectInfiltrometerType = (state) => state.baerInitialize.infiltrometerType;\r\n\r\nexport const selectInfiltrometerRadius = (state) => state.baerInitialize.infiltrometerR;\r\n\r\nexport const selectInfiltrometerSuction = (state) => state.baerInitialize.suction;\r\n\r\nexport const selectSoilType = (state) => state.baerInitialize.soilType;\r\n\r\nexport const selectInitialVolume = (state) => state.baerInitialize.initialVolume;\r\n\r\nexport const selectInfiltrometerData = (state) => state.baerInitialize;\r\n\r\nexport const selectTimeInterval = (state) => state.baerInitialize.timeInterval;\r\n\r\n\r\n//export the actions\r\nexport const { setInfiltrometerType, setInitialVolume, setInfiltrometerSuction, setTimeInterval, setSoilType } = baerInitializeSlice.actions;\r\n\r\n\r\n\r\nexport default baerInitializeSlice.reducer;","C:\\Users\\caboo\\OneDrive\\Documents\\GitHub\\Infiltrometer\\infiltrometer21\\src\\features\\baer-replication\\bear-replicationSlice.js",[],"C:\\Users\\caboo\\OneDrive\\Documents\\GitHub\\Infiltrometer\\infiltrometer21\\src\\features\\reports\\ShowReportsButon.js",["90","91","92"],"import React, { useState } from 'react';\r\nimport { useSelector, useDispatch } from 'react-redux';\r\nimport {selectReports\r\n} from './reportsSlice';\r\n\r\nlet reports;\r\nfunction PrintReports(){\r\n  reports = useSelector(selectReports)\r\n  console.log(reports);\r\n}\r\n\r\nexport function ShowReportsButton() {\r\n    const reports = useSelector(selectReports);\r\n\r\n    return(\r\n    <div>\r\n        <button onClick={()=>console.log(reports)}>\r\n            Show Reports in Store\r\n        </button>\r\n    </div>\r\n\r\n  );\r\n\r\n}","C:\\Users\\caboo\\OneDrive\\Documents\\GitHub\\Infiltrometer\\infiltrometer21\\src\\features\\baer-initialize\\BaerInitializeView.js",["93","94","95","96","97","98","99","100"],"//The Page we are displaying for the baer Initialize view\r\nimport { Link } from 'react-router-dom';\r\nimport React, {useState} from 'react';\r\nimport { useDispatch, useSelector } from 'react-redux';\r\nimport { newReport } from '../reports/reportsSlice';\r\nimport {Protocols} from '../reports/protocols'\r\nimport { selectInitialVolume, selectInfiltrometerData,\r\n  selectInfiltrometerRadius, selectInfiltrometerSuction,\r\nsetInitialVolume,\r\nsetInfiltrometerSuction, setTimeInterval, selectTimeInterval,setSoilType,selectSoilType} from './bear-initializeSlice';\r\nimport { Redirect } from 'react-router';\r\nimport { useEffect } from 'react';\r\nimport { setLastVolume } from '../baer-replication/bear-replicationSlice';\r\nimport { soilTypes } from '../../app/soilTypes';\r\n\r\n\r\n\r\n\r\nconst BaerInitializeView = () => {\r\n  \r\n\r\n  const initailState = {\r\n    validated: false,\r\n    redirect: null\r\n  };\r\n\r\n  const [state, setState] = useState(false);\r\n\r\n  //current soil type in the store\r\n  const curSoilType = useSelector(selectSoilType);\r\n  \r\n  /**\r\n   * Goes to baer replication page when we set the redirect\r\n   * flag to true\r\n   * @returns \r\n   */\r\n  const Redirector = () =>{\r\n    return state.redirect!=null ? <Redirect to ={state.redirect}/> : null;\r\n  }\r\n\r\n  const infiltrometerData = useSelector(selectInfiltrometerData);\r\n  const dispatch = useDispatch();\r\n  /**\r\n   * Adds a new Baer prototocol report using the reports slice\r\n   */\r\n  const generateNewBaerReport=()=>{\r\n\r\n    //TODO: validate the input\r\n    setState({...state,\r\n      validated: true});\r\n\r\n\r\n\r\n    //dispatch the new report with valid input\r\n    dispatch(newReport({\r\n     \r\n      protocol: Protocols.Baer,\r\n      //new Date() initializes to the current Date\r\n      date: (new Date()).toString(),    \r\n      infiltrometerData\r\n    })\r\n    );\r\n\r\n\r\n      //set our redirect flag to true\r\n      setState({...state,redirect: \"/Infiltrometer/baer-replication\"});\r\n    \r\n  }\r\n  /**Makes sure the current initial volume in the store is valid\r\n   * @returns true if valid, false if not valid\r\n   * @param {\\The volume to check for validation} volume \r\n   */\r\n  function ValidateInitialVolume(){\r\n      let volume = useSelector(selectInitialVolume);\r\n      return (volume > 0);\r\n  }\r\n  /**\r\n   * @returns true if valid, false if not valid\r\n   * @param {the infitrometerType to check for validation} infiltrometerType \r\n   */\r\n  function ValidateInfiltromterType(infiltrometerType){\r\n\r\n  } \r\n  /** validates suction\r\n   * @returns true if valid, false if not valid\r\n   * @param {the suction to check for validation} suction\r\n   */\r\n  function ValidateSuction() {\r\n      let suction = useSelector(selectInfiltrometerSuction);\r\n      return (suction > 0);\r\n  }\r\n  /**validates time interval\r\n   * \r\n   * @returns ture if valid, otherwise false.\r\n   * @param {the time interval to check for validation}\r\n   */\r\n  function ValidateTimeInterval() {\r\n    let timeInterval = useSelector(selectTimeInterval);\r\n\r\n    return (timeInterval > 0);\r\n  }\r\n\r\n\r\n\r\n  return (\r\n  <div class = \"col-sm\">\r\n  <div>\r\n    <h1>\r\n      Initialize Baer Protocol\r\n    </h1>\r\n      <Link to =\"/Infiltrometer/baer-replication\">To Replication View</Link>\r\n    </div>\r\n        <div>\r\n\r\n    </div>\r\n  <div class=\"container\">\r\n\r\n  <div class=\"form-group row\">\r\n    <label for=\"inputVolume\" class=\"col-sm-2 col-form-label\" >Initial Volume</label>\r\n    <div class=\"col-sm-10\">\r\n      <input type=\"number\" class=\"form-control\" id=\"inputVolume\" onChange = {\r\n        \r\n        //set the initial volume and the last volume in redux when the text changes\r\n\r\n        (evt)=>{dispatch(setInitialVolume(Number(evt.target.value)));\r\n                dispatch(setLastVolume(Number(evt.target.value)))}\r\n        \r\n        \r\n        } placeholder=\"Enter Volume\"/>\r\n    </div>\r\n  </div>\r\n  <div class=\"form-group row\">\r\n    <label for=\"inputSuction\" class=\"col-sm-2 col-form-label\">Suction</label>\r\n    <div class=\"col-sm-10\">\r\n      <input type=\"number\" class=\"form-control\" id=\"inputSuction\"  onChange = {\r\n        \r\n        //set the suction in redux when the text changes\r\n\r\n        (evt)=>dispatch(setInfiltrometerSuction(Number(evt.target.value)))\r\n        \r\n        } placeholder=\"Enter Suction\"/>\r\n    </div>\r\n  </div>\r\n  <div class=\"form-group row\">\r\n    <label for=\"inputTimeInterval\" class=\"col-sm-2 col-form-label\" >Time Interval</label>\r\n    <div class=\"col-sm-10\">\r\n      <input type=\"number\" class=\"form-control\" id=\"inputTimeInterval\" placeholder=\"Enter Time Interval\" onChange = {\r\n        \r\n        //set the suction in redux when the text changes\r\n\r\n        (text)=>dispatch(setTimeInterval(Number(text.target.value)))\r\n        \r\n        }/>\r\n    </div>\r\n  </div>\r\n  \r\n  <fieldset class=\"form-group\">\r\n    <div class=\"row\">\r\n      <legend class=\"col-form-label col-sm-2 pt-0\">Soil Type</legend>\r\n      <div class=\"col-sm-10\">\r\n        <div class=\"form-check\">\r\n          <input class=\"form-check-input\" type=\"radio\" name=\"gridRadios\" id=\"clayRadio\" value=\"option1\"\r\n          checked = {curSoilType == soilTypes.clay} onChange = {\r\n            (evt)=>dispatch(setSoilType(soilTypes.clay))\r\n          }/>\r\n          <label class=\"form-check-label\" for=\"clayRadio\">\r\n            Clay\r\n          </label>\r\n        </div>\r\n        <div class=\"form-check\">\r\n          <input class=\"form-check-input\" type=\"radio\" name=\"gridRadios\" id=\"loamRadio\" value=\"option2\"onChange = {\r\n            (evt)=>dispatch(setSoilType(soilTypes.loam))\r\n          }/>\r\n          <label class=\"form-check-label\" for=\"loamRadio\">\r\n            Loam\r\n          </label>\r\n        </div>\r\n        <div class=\"form-check\">\r\n          <input class=\"form-check-input\" type=\"radio\" name=\"gridRadios\" id=\"clayLoamRadio\" value=\"option3\"onChange = {\r\n            (evt)=>dispatch(setSoilType(soilTypes.clayLoam))\r\n          }/>\r\n          <label class=\"form-check-label\" for=\"clayLoamRadio\">\r\n            Clay Loam\r\n          </label>\r\n        </div>\r\n        <div class=\"form-check\">\r\n          <input class=\"form-check-input\" type=\"radio\" name=\"gridRadios\" id=\"customRadio\" value=\"option4\"onChange = {\r\n            (evt)=>dispatch(setSoilType(soilTypes.default))\r\n          }/>\r\n          <label class=\"form-check-label\" for=\"customRadio\">\r\n            Custom\r\n          </label>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  </fieldset>\r\n  <div class=\"form-group row\">\r\n   <button type=\"submit\" class=\"btn btn-primary\" onClick = {generateNewBaerReport}>Start Protocol</button>\r\n  </div>\r\n    </div>\r\n    <Redirector/>\r\n  </div>\r\n     );\r\n}\r\nexport default BaerInitializeView;","C:\\Users\\caboo\\OneDrive\\Documents\\GitHub\\Infiltrometer\\infiltrometer21\\src\\features\\baer-results\\bear-resultsSlice.js",["101"],"import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';\r\n\r\n\r\n\r\nconst initialState = {\r\n    volume: 0,\r\n    secondsElapsed: 0,\r\n};\r\n\r\nexport const baerResultsSlice = createSlice({\r\n    name: 'baerResults',\r\n  initialState,\r\n  // The `reducers` field lets us define reducers and generate associated actions\r\n  reducers: {\r\n\r\n\r\n\r\n\r\n\r\n\r\n  }\r\n});\r\nexport default baerResultsSlice.reducer;","C:\\Users\\caboo\\OneDrive\\Documents\\GitHub\\Infiltrometer\\infiltrometer21\\src\\features\\reports\\reportsSlice.js",["102"],"import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';\r\n\r\n\r\n\r\n\r\n//empty array of reports\r\nconst initialState = {\r\n    reports:[],\r\n    curId: -1\r\n};\r\n\r\nexport const reportsSlice = createSlice({\r\n  name: 'baerResults',\r\n  initialState,\r\n  // The `reducers` field lets us define reducers and generate associated actions\r\n  reducers: {\r\n     newReport: (state, action) => {\r\n      // Push a new report onto the report stack and increment the id\r\n      state.curId++;\r\n      state.reports = [...state.reports,(\r\n        {\r\n            id: state.curId,\r\n            date: action.payload.date,\r\n            protocol: action.payload.protocol,\r\n            readings: [],\r\n            infiltrometerData: action.payload.infiltrometerData\r\n        }\r\n      )];\r\n\r\n    },\r\n\r\n    /** Adds a reading to the report with the provided id\r\n     * action needs an \r\n     * @param id\r\n     * @param reading\r\n     * \r\n     */\r\n    addReading: (state, action)=>{\r\n      //add the reading to the end of the list of readings\r\n        state.reports[state.curId].readings =\r\n        [...state.reports[state.curId].readings, \r\n        action.payload]; \r\n    }\r\n  }\r\n});\r\n\r\nexport const { newReport, addReading } = reportsSlice.actions;\r\nexport const selectReports = (state) => state.reports.reports;\r\n\r\nexport default reportsSlice.reducer;","C:\\Users\\caboo\\OneDrive\\Documents\\GitHub\\Infiltrometer\\infiltrometer21\\src\\features\\regression\\RegressionTesting.js",[],"C:\\Users\\caboo\\OneDrive\\Documents\\GitHub\\Infiltrometer\\infiltrometer21\\src\\features\\baer-results\\BaerResultsView.js",["103"],"C:\\Users\\caboo\\OneDrive\\Documents\\GitHub\\Infiltrometer\\infiltrometer21\\src\\features\\counter\\counterSlice.js",[],"C:\\Users\\caboo\\OneDrive\\Documents\\GitHub\\Infiltrometer\\infiltrometer21\\src\\app\\soilTypes.js",[],"C:\\Users\\caboo\\OneDrive\\Documents\\GitHub\\Infiltrometer\\infiltrometer21\\src\\features\\reports\\protocols.js",[],"C:\\Users\\caboo\\OneDrive\\Documents\\GitHub\\Infiltrometer\\infiltrometer21\\src\\features\\counter\\counterAPI.js",[],"C:\\Users\\caboo\\OneDrive\\Documents\\GitHub\\Infiltrometer\\infiltrometer21\\src\\features\\regression\\regression-js.js",["104"],"const DEFAULT_OPTIONS = { order: 2, precision: 2, period: null };\r\n\r\n/**\r\n* Determine the coefficient of determination (r^2) of a fit from the observations\r\n* and predictions.\r\n*\r\n* @param {Array<Array<number>>} data - Pairs of observed x-y values\r\n* @param {Array<Array<number>>} results - Pairs of observed predicted x-y values\r\n*\r\n* @return {number} - The r^2 value, or NaN if one cannot be calculated.\r\n*/\r\nfunction determinationCoefficient(data, results) {\r\n  const predictions = [];\r\n  const observations = [];\r\n\r\n  data.forEach((d, i) => {\r\n    if (d[1] !== null) {\r\n      observations.push(d);\r\n      predictions.push(results[i]);\r\n    }\r\n  });\r\n\r\n  const sum = observations.reduce((a, observation) => a + observation[1], 0);\r\n  const mean = sum / observations.length;\r\n\r\n  const ssyy = observations.reduce((a, observation) => {\r\n    const difference = observation[1] - mean;\r\n    return a + (difference * difference);\r\n  }, 0);\r\n\r\n  const sse = observations.reduce((accum, observation, index) => {\r\n    const prediction = predictions[index];\r\n    const residual = observation[1] - prediction[1];\r\n    return accum + (residual * residual);\r\n  }, 0);\r\n\r\n  return 1 - (sse / ssyy);\r\n}\r\n\r\n/**\r\n* Determine the solution of a system of linear equations A * x = b using\r\n* Gaussian elimination.\r\n*\r\n* @param {Array<Array<number>>} input - A 2-d matrix of data in row-major form [ A | b ]\r\n* @param {number} order - How many degrees to solve for\r\n*\r\n* @return {Array<number>} - Vector of normalized solution coefficients matrix (x)\r\n*/\r\nfunction gaussianElimination(input, order) {\r\n  const matrix = input;\r\n  const n = input.length - 1;\r\n  const coefficients = [order];\r\n\r\n  for (let i = 0; i < n; i++) {\r\n    let maxrow = i;\r\n    for (let j = i + 1; j < n; j++) {\r\n      if (Math.abs(matrix[i][j]) > Math.abs(matrix[i][maxrow])) {\r\n        maxrow = j;\r\n      }\r\n    }\r\n\r\n    for (let k = i; k < n + 1; k++) {\r\n      const tmp = matrix[k][i];\r\n      matrix[k][i] = matrix[k][maxrow];\r\n      matrix[k][maxrow] = tmp;\r\n    }\r\n\r\n    for (let j = i + 1; j < n; j++) {\r\n      for (let k = n; k >= i; k--) {\r\n        matrix[k][j] -= (matrix[k][i] * matrix[i][j]) / matrix[i][i];\r\n      }\r\n    }\r\n  }\r\n\r\n  for (let j = n - 1; j >= 0; j--) {\r\n    let total = 0;\r\n    for (let k = j + 1; k < n; k++) {\r\n      total += matrix[k][j] * coefficients[k];\r\n    }\r\n\r\n    coefficients[j] = (matrix[n][j] - total) / matrix[j][j];\r\n  }\r\n\r\n  return coefficients;\r\n}\r\n\r\n/**\r\n* Round a number to a precision, specificed in number of decimal places\r\n*\r\n* @param {number} number - The number to round\r\n* @param {number} precision - The number of decimal places to round to:\r\n*                             > 0 means decimals, < 0 means powers of 10\r\n*\r\n*\r\n* @return {numbr} - The number, rounded\r\n*/\r\nfunction round(number, precision) {\r\n  const factor = 10 ** precision;\r\n  return Math.round(number * factor) / factor;\r\n}\r\n\r\n/**\r\n* The set of all fitting methods\r\n*\r\n* @namespace\r\n*/\r\nexport const methods = {\r\n  linear(data, options) {\r\n    const sum = [0, 0, 0, 0, 0];\r\n    let len = 0;\r\n\r\n    for (let n = 0; n < data.length; n++) {\r\n      if (data[n][1] !== null) {\r\n        len++;\r\n        sum[0] += data[n][0];\r\n        sum[1] += data[n][1];\r\n        sum[2] += data[n][0] * data[n][0];\r\n        sum[3] += data[n][0] * data[n][1];\r\n        sum[4] += data[n][1] * data[n][1];\r\n      }\r\n    }\r\n\r\n    const run = ((len * sum[2]) - (sum[0] * sum[0]));\r\n    const rise = ((len * sum[3]) - (sum[0] * sum[1]));\r\n    const gradient = run === 0 ? 0 : round(rise / run, options.precision);\r\n    const intercept = round((sum[1] / len) - ((gradient * sum[0]) / len), options.precision);\r\n\r\n    const predict = x => ([\r\n      round(x, options.precision),\r\n      round((gradient * x) + intercept, options.precision)]\r\n    );\r\n\r\n    const points = data.map(point => predict(point[0]));\r\n\r\n    return {\r\n      points,\r\n      predict,\r\n      equation: [gradient, intercept],\r\n      r2: round(determinationCoefficient(data, points), options.precision),\r\n      string: intercept === 0 ? `y = ${gradient}x` : `y = ${gradient}x + ${intercept}`,\r\n    };\r\n  },\r\n\r\n  exponential(data, options) {\r\n    const sum = [0, 0, 0, 0, 0, 0];\r\n\r\n    for (let n = 0; n < data.length; n++) {\r\n      if (data[n][1] !== null) {\r\n        sum[0] += data[n][0];\r\n        sum[1] += data[n][1];\r\n        sum[2] += data[n][0] * data[n][0] * data[n][1];\r\n        sum[3] += data[n][1] * Math.log(data[n][1]);\r\n        sum[4] += data[n][0] * data[n][1] * Math.log(data[n][1]);\r\n        sum[5] += data[n][0] * data[n][1];\r\n      }\r\n    }\r\n\r\n    const denominator = ((sum[1] * sum[2]) - (sum[5] * sum[5]));\r\n    const a = Math.exp(((sum[2] * sum[3]) - (sum[5] * sum[4])) / denominator);\r\n    const b = ((sum[1] * sum[4]) - (sum[5] * sum[3])) / denominator;\r\n    const coeffA = round(a, options.precision);\r\n    const coeffB = round(b, options.precision);\r\n    const predict = x => ([\r\n      round(x, options.precision),\r\n      round(coeffA * Math.exp(coeffB * x), options.precision),\r\n    ]);\r\n\r\n    const points = data.map(point => predict(point[0]));\r\n\r\n    return {\r\n      points,\r\n      predict,\r\n      equation: [coeffA, coeffB],\r\n      string: `y = ${coeffA}e^(${coeffB}x)`,\r\n      r2: round(determinationCoefficient(data, points), options.precision),\r\n    };\r\n  },\r\n\r\n  logarithmic(data, options) {\r\n    const sum = [0, 0, 0, 0];\r\n    const len = data.length;\r\n\r\n    for (let n = 0; n < len; n++) {\r\n      if (data[n][1] !== null) {\r\n        sum[0] += Math.log(data[n][0]);\r\n        sum[1] += data[n][1] * Math.log(data[n][0]);\r\n        sum[2] += data[n][1];\r\n        sum[3] += (Math.log(data[n][0]) ** 2);\r\n      }\r\n    }\r\n\r\n    const a = ((len * sum[1]) - (sum[2] * sum[0])) / ((len * sum[3]) - (sum[0] * sum[0]));\r\n    const coeffB = round(a, options.precision);\r\n    const coeffA = round((sum[2] - (coeffB * sum[0])) / len, options.precision);\r\n\r\n    const predict = x => ([\r\n      round(x, options.precision),\r\n      round(round(coeffA + (coeffB * Math.log(x)), options.precision), options.precision),\r\n    ]);\r\n\r\n    const points = data.map(point => predict(point[0]));\r\n\r\n    return {\r\n      points,\r\n      predict,\r\n      equation: [coeffA, coeffB],\r\n      string: `y = ${coeffA} + ${coeffB} ln(x)`,\r\n      r2: round(determinationCoefficient(data, points), options.precision),\r\n    };\r\n  },\r\n\r\n  power(data, options) {\r\n    const sum = [0, 0, 0, 0, 0];\r\n    const len = data.length;\r\n\r\n    for (let n = 0; n < len; n++) {\r\n      if (data[n][1] !== null) {\r\n        sum[0] += Math.log(data[n][0]);\r\n        sum[1] += Math.log(data[n][1]) * Math.log(data[n][0]);\r\n        sum[2] += Math.log(data[n][1]);\r\n        sum[3] += (Math.log(data[n][0]) ** 2);\r\n      }\r\n    }\r\n\r\n    const b = ((len * sum[1]) - (sum[0] * sum[2])) / ((len * sum[3]) - (sum[0] ** 2));\r\n    const a = ((sum[2] - (b * sum[0])) / len);\r\n    const coeffA = round(Math.exp(a), options.precision);\r\n    const coeffB = round(b, options.precision);\r\n\r\n    const predict = x => ([\r\n      round(x, options.precision),\r\n      round(round(coeffA * (x ** coeffB), options.precision), options.precision),\r\n    ]);\r\n\r\n    const points = data.map(point => predict(point[0]));\r\n\r\n    return {\r\n      points,\r\n      predict,\r\n      equation: [coeffA, coeffB],\r\n      string: `y = ${coeffA}x^${coeffB}`,\r\n      r2: round(determinationCoefficient(data, points), options.precision),\r\n    };\r\n  },\r\n\r\n  polynomial(data, options) {\r\n    const lhs = [];\r\n    const rhs = [];\r\n    let a = 0;\r\n    let b = 0;\r\n\r\n    const len = data.length;\r\n    const k = options.order + 1;\r\n\r\n    for (let i = 1; i < k; i++) {\r\n      for (let l = 0; l < len; l++) {\r\n        if (data[l][1] !== null) {\r\n          a += (data[l][0] ** i) * data[l][1];\r\n        }\r\n      }\r\n\r\n      lhs.push(a);\r\n      a = 0;\r\n\r\n      const c = [];\r\n      for (let j = 1; j < k; j++) {\r\n        for (let l = 0; l < len; l++) {\r\n          if (data[l][1] !== null) {\r\n            b += data[l][0] ** (i + j);\r\n          }\r\n        }\r\n        c.push(b);\r\n        b = 0;\r\n      }\r\n      rhs.push(c);\r\n    }\r\n    rhs.push(lhs);\r\n\r\n    const coefficients = [0,...gaussianElimination(rhs, k).map(v => round(v, options.precision))];\r\n    const predict = x => ([\r\n      round(x, options.precision),\r\n      round(\r\n        coefficients.reduce((sum, coeff, power) => sum + (coeff * (x ** power)), 0),\r\n        options.precision,\r\n      ),\r\n    ]);\r\n\r\n    const points = data.map(point => predict(point[0]));\r\n\r\n    let string = 'y = ';\r\n    for (let i = coefficients.length - 1; i >= 0; i--) {\r\n      if (i > 1) {\r\n        string += `${coefficients[i]}x^${i} + `;\r\n      } else if (i === 1) {\r\n        string += `${coefficients[i]}x + `;\r\n      } else {\r\n        string += coefficients[i];\r\n      }\r\n    }\r\n\r\n    return {\r\n      string,\r\n      points,\r\n      predict,\r\n      equation: [...coefficients].reverse(),\r\n      r2: round(determinationCoefficient(data, points), options.precision),\r\n    };\r\n  },\r\n};\r\n\r\nfunction createWrapper() {\r\n  const reduce = (accumulator, name) => ({\r\n    _round: round,\r\n    ...accumulator,\r\n    [name](data, supplied) {\r\n      return methods[name](data, {\r\n        ...DEFAULT_OPTIONS,\r\n        ...supplied,\r\n      });\r\n    },\r\n  });\r\n\r\n  return Object.keys(methods).reduce(reduce, {});\r\n}\r\n",{"ruleId":"105","replacedBy":"106"},{"ruleId":"107","replacedBy":"108"},{"ruleId":"109","severity":1,"message":"110","line":4,"column":8,"nodeType":"111","messageId":"112","endLine":4,"endColumn":16},{"ruleId":"109","severity":1,"message":"113","line":8,"column":51,"nodeType":"111","messageId":"112","endLine":8,"endColumn":62},{"ruleId":"109","severity":1,"message":"114","line":11,"column":8,"nodeType":"111","messageId":"112","endLine":11,"endColumn":16},{"ruleId":"109","severity":1,"message":"115","line":12,"column":10,"nodeType":"111","messageId":"112","endLine":12,"endColumn":19},{"ruleId":"109","severity":1,"message":"116","line":42,"column":9,"nodeType":"111","messageId":"112","endLine":42,"endColumn":20},{"ruleId":"109","severity":1,"message":"117","line":1,"column":10,"nodeType":"111","messageId":"112","endLine":1,"endColumn":26},{"ruleId":"109","severity":1,"message":"118","line":1,"column":17,"nodeType":"111","messageId":"112","endLine":1,"endColumn":25},{"ruleId":"109","severity":1,"message":"119","line":2,"column":23,"nodeType":"111","messageId":"112","endLine":2,"endColumn":34},{"ruleId":"109","severity":1,"message":"120","line":7,"column":10,"nodeType":"111","messageId":"112","endLine":7,"endColumn":22},{"ruleId":"109","severity":1,"message":"121","line":8,"column":3,"nodeType":"111","messageId":"112","endLine":8,"endColumn":28},{"ruleId":"109","severity":1,"message":"115","line":12,"column":10,"nodeType":"111","messageId":"112","endLine":12,"endColumn":19},{"ruleId":"109","severity":1,"message":"122","line":22,"column":9,"nodeType":"111","messageId":"112","endLine":22,"endColumn":21},{"ruleId":"109","severity":1,"message":"123","line":73,"column":12,"nodeType":"111","messageId":"112","endLine":73,"endColumn":33},{"ruleId":"109","severity":1,"message":"124","line":81,"column":12,"nodeType":"111","messageId":"112","endLine":81,"endColumn":36},{"ruleId":"109","severity":1,"message":"125","line":88,"column":12,"nodeType":"111","messageId":"112","endLine":88,"endColumn":27},{"ruleId":"109","severity":1,"message":"126","line":97,"column":12,"nodeType":"111","messageId":"112","endLine":97,"endColumn":32},{"ruleId":"127","severity":1,"message":"128","line":163,"column":34,"nodeType":"129","messageId":"130","endLine":163,"endColumn":36},{"ruleId":"109","severity":1,"message":"117","line":1,"column":10,"nodeType":"111","messageId":"112","endLine":1,"endColumn":26},{"ruleId":"109","severity":1,"message":"117","line":1,"column":10,"nodeType":"111","messageId":"112","endLine":1,"endColumn":26},{"ruleId":"109","severity":1,"message":"119","line":4,"column":21,"nodeType":"111","messageId":"112","endLine":4,"endColumn":32},{"ruleId":"109","severity":1,"message":"131","line":311,"column":10,"nodeType":"111","messageId":"112","endLine":311,"endColumn":23},"no-native-reassign",["132"],"no-negated-in-lhs",["133"],"no-unused-vars","'ReactDOM' is defined but never used.","Identifier","unusedVar","'setSoilType' is defined but never used.","'_default' is defined but never used.","'useEffect' is defined but never used.","'curSoilType' is assigned a value but never used.","'createAsyncThunk' is defined but never used.","'useState' is defined but never used.","'useDispatch' is defined but never used.","'PrintReports' is defined but never used.","'selectInfiltrometerRadius' is defined but never used.","'initailState' is assigned a value but never used.","'ValidateInitialVolume' is defined but never used.","'ValidateInfiltromterType' is defined but never used.","'ValidateSuction' is defined but never used.","'ValidateTimeInterval' is defined but never used.","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","'createWrapper' is defined but never used.","no-global-assign","no-unsafe-negation"]