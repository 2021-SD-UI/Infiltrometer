[{"E:\\Infiltrometer\\infiltrometer21\\src\\index.js":"1","E:\\Infiltrometer\\infiltrometer21\\src\\App.js":"2","E:\\Infiltrometer\\infiltrometer21\\src\\serviceWorker.js":"3","E:\\Infiltrometer\\infiltrometer21\\src\\app\\store.js":"4","E:\\Infiltrometer\\infiltrometer21\\src\\features\\baer-initialize\\BaerInitializeView.js":"5","E:\\Infiltrometer\\infiltrometer21\\src\\features\\baer-initialize\\bear-initializeSlice.js":"6","E:\\Infiltrometer\\infiltrometer21\\src\\features\\baer-replication\\BaerReplicationView.js":"7","E:\\Infiltrometer\\infiltrometer21\\src\\features\\counter\\Counter.js":"8","E:\\Infiltrometer\\infiltrometer21\\src\\features\\counter\\counterSlice.js":"9","E:\\Infiltrometer\\infiltrometer21\\src\\features\\baer-results\\bear-resultsSlice.js":"10","E:\\Infiltrometer\\infiltrometer21\\src\\features\\baer-results\\BaerResultsView.js":"11","E:\\Infiltrometer\\infiltrometer21\\src\\features\\baer-replication\\bear-replicationSlice.js":"12","E:\\Infiltrometer\\infiltrometer21\\src\\features\\counter\\counterAPI.js":"13","E:\\Infiltrometer\\infiltrometer21\\src\\features\\reports\\reportsSlice.js":"14","E:\\Infiltrometer\\infiltrometer21\\src\\features\\reports\\ShowReportsButon.js":"15","E:\\Infiltrometer\\infiltrometer21\\src\\features\\reports\\protocols.js":"16","E:\\Infiltrometer\\infiltrometer21\\src\\features\\regression\\RegressionTesting.js":"17","E:\\Infiltrometer\\infiltrometer21\\src\\features\\regression\\regression-js.js":"18","E:\\Infiltrometer\\infiltrometer21\\src\\app\\soilTypes.js":"19"},{"size":661,"mtime":1631964288211,"results":"20","hashOfConfig":"21"},{"size":1409,"mtime":1632154961944,"results":"22","hashOfConfig":"21"},{"size":5151,"mtime":1631899423581,"results":"23","hashOfConfig":"21"},{"size":684,"mtime":1631962504517,"results":"24","hashOfConfig":"21"},{"size":1664,"mtime":1632178458034,"results":"25","hashOfConfig":"21"},{"size":1629,"mtime":1632178048140,"results":"26","hashOfConfig":"21"},{"size":365,"mtime":1631962504575,"results":"27","hashOfConfig":"21"},{"size":1826,"mtime":1631837654030,"results":"28","hashOfConfig":"21"},{"size":2819,"mtime":1631899423578,"results":"29","hashOfConfig":"21"},{"size":335,"mtime":1631962504591,"results":"30","hashOfConfig":"21"},{"size":361,"mtime":1631964644219,"results":"31","hashOfConfig":"21"},{"size":574,"mtime":1632178944112,"results":"32","hashOfConfig":"21"},{"size":202,"mtime":1631899423578,"results":"33","hashOfConfig":"21"},{"size":1183,"mtime":1632178814025,"results":"34","hashOfConfig":"21"},{"size":504,"mtime":1631964263984,"results":"35","hashOfConfig":"21"},{"size":175,"mtime":1631965019821,"results":"36","hashOfConfig":"21"},{"size":1085,"mtime":1632005081692,"results":"37","hashOfConfig":"21"},{"size":9271,"mtime":1632005979115,"results":"38","hashOfConfig":"21"},{"size":569,"mtime":1632176858189,"results":"39","hashOfConfig":"21"},{"filePath":"40","messages":"41","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"c42c6c",{"filePath":"42","messages":"43","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"44","messages":"45","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"46","messages":"47","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"48","messages":"49","errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"50"},{"filePath":"51","messages":"52","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"53"},{"filePath":"54","messages":"55","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"56","messages":"57","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"58"},{"filePath":"59","messages":"60","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"61","messages":"62","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"63"},{"filePath":"64","messages":"65","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"66","messages":"67","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"68"},{"filePath":"69","messages":"70","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"71","messages":"72","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"73"},{"filePath":"74","messages":"75","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"76"},{"filePath":"77","messages":"78","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"79","messages":"80","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"81","messages":"82","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"83"},{"filePath":"84","messages":"85","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"E:\\Infiltrometer\\infiltrometer21\\src\\index.js",[],"E:\\Infiltrometer\\infiltrometer21\\src\\App.js",[],"E:\\Infiltrometer\\infiltrometer21\\src\\serviceWorker.js",[],"E:\\Infiltrometer\\infiltrometer21\\src\\app\\store.js",[],"E:\\Infiltrometer\\infiltrometer21\\src\\features\\baer-initialize\\BaerInitializeView.js",["86","87","88","89","90"],"//The Page we are displaying for the baer Initialize view\r\nimport { Link } from 'react-router-dom';\r\nimport React from 'react';\r\nimport { useDispatch, useSelector } from 'react-redux';\r\nimport { newReport } from '../reports/reportsSlice';\r\nimport {Protocols} from '../reports/protocols'\r\nimport { selectInitialVolume, selectInfiltrometerData,\r\n  \r\n  selectInfiltrometerRadius, selectInfiltrometerSuction } from './bear-initializeSlice';\r\nconst BaerInitializeView = () => {\r\n\r\n  const dispatch = useDispatch();\r\n\r\n\r\n  /**\r\n   * Adds a new Baer prototocol report using the reports slice\r\n   */\r\n  const generateNewBaerReport=()=>{\r\n\r\n\r\n    dispatch(newReport({\r\n     \r\n      protocol: Protocols.Baer,\r\n      //new Date() initializes to the current Date\r\n      date: (new Date()).toString(),\r\n     \r\n      infiltrometerData: 0\r\n    })\r\n    \r\n    );\r\n  }\r\n  /**Makes sure the current initial volume in the store is valid\r\n   * @returns true if valid, false if not valid\r\n   * @param {\\The volume to check for validation} volume \r\n   */\r\n  function ValidateInitialVolume(){\r\n      let volume = useSelector(selectInitialVolume);\r\n      return (volume > 0);\r\n  }\r\n  /**\r\n   * @returns true if valid, false if not valid\r\n   * @param {the infitrometerType to check for validation} infiltrometerType \r\n   */\r\n  function ValidateInfiltromterType(infiltrometerType){\r\n\r\n  }\r\n\r\n\r\n\r\n  return (<div>\r\n    <button onClick = {generateNewBaerReport}>\r\n      Add new Baer Report\r\n    </button>\r\n    <div>\r\n      Bear Initialize View\r\n    </div>\r\n      <Link to =\"/Infiltrometer/baer-replication\">To Replication View</Link>\r\n      \r\n    </div>);\r\n}\r\nexport default BaerInitializeView;","E:\\Infiltrometer\\infiltrometer21\\src\\features\\baer-initialize\\bear-initializeSlice.js",["91"],"import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';\r\nimport { soilTypes } from '../../app/soilTypes';\r\n\r\n const initialState = {  \r\n        initialVolume: 0,\r\n        \r\n        coordinates: {\r\n          lat:0,\r\n          long: 0,\r\n        },\r\n\r\n        soilType: soilTypes.default,\r\n        \r\n        infiltrometerRadius: 0,\r\n        \r\n        timeInterval: 30\r\n\r\n};\r\n\r\n\r\n\r\n/**\r\n * We need slices to \r\n */\r\nexport const baerInitializeSlice = createSlice({\r\n    name: 'baerInitialize',\r\n  initialState,\r\n  // The `reducers` field lets us define reducers and generate associated actions\r\n  reducers: {\r\n    //Update the appropritate values to the provided infiltrometer type  \r\n    \r\n    setInfiltrometerType: (state, action) => {\r\n      \r\n      switch (action.payload.infiltrometerType){\r\n        default:\r\n          //set the radius to 0\r\n          state.infiltrometerR = 0;\r\n          break;\r\n\r\n      }\r\n    },\r\n    setInitialVolume: (state, action)=>{\r\n\r\n      state.initialVolume = action.payload.initialVolume;\r\n    \r\n    }\r\n\r\n  }\r\n});\r\n\r\n/**\r\n * A selector returning the current type of the infiltrometer\r\n * @param {*} state \r\n * @returns \r\n */\r\nexport const selectInfiltrometerType = (state) => state.infiltrometerType;\r\n\r\nexport const selectInfiltrometerRadius = (state) => state.infiltrometerR;\r\n\r\nexport const selectInfiltrometerSuction = (state) => state.suction;\r\n\r\nexport const selectSoilType = (state) => state.soilType;\r\n\r\nexport const selectInitialVolume = (state) => state.initialVolume;\r\n\r\nexport const selectInfiltrometerData = (state) => state;\r\n\r\n\r\n\r\nexport default baerInitializeSlice.reducer;","E:\\Infiltrometer\\infiltrometer21\\src\\features\\baer-replication\\BaerReplicationView.js",[],"E:\\Infiltrometer\\infiltrometer21\\src\\features\\counter\\Counter.js",[],["92","93"],"E:\\Infiltrometer\\infiltrometer21\\src\\features\\counter\\counterSlice.js",[],"E:\\Infiltrometer\\infiltrometer21\\src\\features\\baer-results\\bear-resultsSlice.js",["94"],"import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';\r\n\r\n\r\n\r\nconst initialState = {};\r\n\r\nexport const baerResultsSlice = createSlice({\r\n    name: 'baerResults',\r\n  initialState,\r\n  // The `reducers` field lets us define reducers and generate associated actions\r\n  reducers: {}\r\n});\r\nexport default baerResultsSlice.reducer;","E:\\Infiltrometer\\infiltrometer21\\src\\features\\baer-results\\BaerResultsView.js",[],"E:\\Infiltrometer\\infiltrometer21\\src\\features\\baer-replication\\bear-replicationSlice.js",["95","96"],"import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';\r\nimport {TimerStateValues} from 'react-compound-timer'\r\n\r\n\r\n/**\r\n * Initialize all the data associated with a reading....\r\n * Dispatch the addReading action from the reportsSlice after validating the reading\r\n */\r\nconst initialState = {\r\n  \r\n\r\n\r\n};\r\n\r\nexport const baerReplicationSlice = createSlice({\r\n    name: 'baerReplication',\r\n  initialState,\r\n  // The `reducers` field lets us define reducers and generate associated actions\r\n  reducers: {}\r\n});\r\n\r\n\r\n\r\n\r\n\r\nexport default baerReplicationSlice.reducer;","E:\\Infiltrometer\\infiltrometer21\\src\\features\\counter\\counterAPI.js",[],"E:\\Infiltrometer\\infiltrometer21\\src\\features\\reports\\reportsSlice.js",["97"],"import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';\r\n\r\n\r\n\r\n\r\n//empty array of reports\r\nconst initialState = {\r\n    reports:[],\r\n    curId: -1\r\n};\r\n\r\nexport const reportsSlice = createSlice({\r\n  name: 'baerResults',\r\n  initialState,\r\n  // The `reducers` field lets us define reducers and generate associated actions\r\n  reducers: {\r\n     newReport: (state, action) => {\r\n      // Push a new report onto the report stack and increment the id\r\n      state.curId++;\r\n      state.reports.push(\r\n        {\r\n            id: state.curId,\r\n            date: action.payload.date,\r\n            protocol: action.payload.protocol,\r\n            readings: [],\r\n            infiltrometerData: action.payload.infiltrometerData\r\n        }\r\n      );\r\n\r\n    },\r\n\r\n    /** Adds a reading to the report with the provided id\r\n     * action needs an \r\n     * @param id\r\n     * @param reading\r\n     * \r\n     */\r\n    addReading: (state, action)=>{\r\n        state.reports[action.payload.id].readings.push(action.payload.reading); \r\n    }\r\n  }\r\n});\r\n\r\nexport const { newReport } = reportsSlice.actions;\r\nexport const selectReports = (state) => state.reports;\r\n\r\nexport default reportsSlice.reducer;","E:\\Infiltrometer\\infiltrometer21\\src\\features\\reports\\ShowReportsButon.js",["98","99","100"],"import React, { useState } from 'react';\r\nimport { useSelector, useDispatch } from 'react-redux';\r\nimport {selectReports\r\n} from './reportsSlice';\r\n\r\nlet reports;\r\nfunction PrintReports(){\r\n  reports = useSelector(selectReports)\r\n  console.log(reports);\r\n}\r\n\r\nexport function ShowReportsButton() {\r\n    const reports = useSelector(selectReports);\r\n\r\n    return(\r\n    <div>\r\n        <button onClick={()=>console.log(reports)}>\r\n            Show Reports in Store\r\n        </button>\r\n    </div>\r\n\r\n  );\r\n\r\n}","E:\\Infiltrometer\\infiltrometer21\\src\\features\\reports\\protocols.js",[],"E:\\Infiltrometer\\infiltrometer21\\src\\features\\regression\\RegressionTesting.js",[],"E:\\Infiltrometer\\infiltrometer21\\src\\features\\regression\\regression-js.js",["101"],"const DEFAULT_OPTIONS = { order: 2, precision: 2, period: null };\r\n\r\n/**\r\n* Determine the coefficient of determination (r^2) of a fit from the observations\r\n* and predictions.\r\n*\r\n* @param {Array<Array<number>>} data - Pairs of observed x-y values\r\n* @param {Array<Array<number>>} results - Pairs of observed predicted x-y values\r\n*\r\n* @return {number} - The r^2 value, or NaN if one cannot be calculated.\r\n*/\r\nfunction determinationCoefficient(data, results) {\r\n  const predictions = [];\r\n  const observations = [];\r\n\r\n  data.forEach((d, i) => {\r\n    if (d[1] !== null) {\r\n      observations.push(d);\r\n      predictions.push(results[i]);\r\n    }\r\n  });\r\n\r\n  const sum = observations.reduce((a, observation) => a + observation[1], 0);\r\n  const mean = sum / observations.length;\r\n\r\n  const ssyy = observations.reduce((a, observation) => {\r\n    const difference = observation[1] - mean;\r\n    return a + (difference * difference);\r\n  }, 0);\r\n\r\n  const sse = observations.reduce((accum, observation, index) => {\r\n    const prediction = predictions[index];\r\n    const residual = observation[1] - prediction[1];\r\n    return accum + (residual * residual);\r\n  }, 0);\r\n\r\n  return 1 - (sse / ssyy);\r\n}\r\n\r\n/**\r\n* Determine the solution of a system of linear equations A * x = b using\r\n* Gaussian elimination.\r\n*\r\n* @param {Array<Array<number>>} input - A 2-d matrix of data in row-major form [ A | b ]\r\n* @param {number} order - How many degrees to solve for\r\n*\r\n* @return {Array<number>} - Vector of normalized solution coefficients matrix (x)\r\n*/\r\nfunction gaussianElimination(input, order) {\r\n  const matrix = input;\r\n  const n = input.length - 1;\r\n  const coefficients = [order];\r\n\r\n  for (let i = 0; i < n; i++) {\r\n    let maxrow = i;\r\n    for (let j = i + 1; j < n; j++) {\r\n      if (Math.abs(matrix[i][j]) > Math.abs(matrix[i][maxrow])) {\r\n        maxrow = j;\r\n      }\r\n    }\r\n\r\n    for (let k = i; k < n + 1; k++) {\r\n      const tmp = matrix[k][i];\r\n      matrix[k][i] = matrix[k][maxrow];\r\n      matrix[k][maxrow] = tmp;\r\n    }\r\n\r\n    for (let j = i + 1; j < n; j++) {\r\n      for (let k = n; k >= i; k--) {\r\n        matrix[k][j] -= (matrix[k][i] * matrix[i][j]) / matrix[i][i];\r\n      }\r\n    }\r\n  }\r\n\r\n  for (let j = n - 1; j >= 0; j--) {\r\n    let total = 0;\r\n    for (let k = j + 1; k < n; k++) {\r\n      total += matrix[k][j] * coefficients[k];\r\n    }\r\n\r\n    coefficients[j] = (matrix[n][j] - total) / matrix[j][j];\r\n  }\r\n\r\n  return coefficients;\r\n}\r\n\r\n/**\r\n* Round a number to a precision, specificed in number of decimal places\r\n*\r\n* @param {number} number - The number to round\r\n* @param {number} precision - The number of decimal places to round to:\r\n*                             > 0 means decimals, < 0 means powers of 10\r\n*\r\n*\r\n* @return {numbr} - The number, rounded\r\n*/\r\nfunction round(number, precision) {\r\n  const factor = 10 ** precision;\r\n  return Math.round(number * factor) / factor;\r\n}\r\n\r\n/**\r\n* The set of all fitting methods\r\n*\r\n* @namespace\r\n*/\r\nexport const methods = {\r\n  linear(data, options) {\r\n    const sum = [0, 0, 0, 0, 0];\r\n    let len = 0;\r\n\r\n    for (let n = 0; n < data.length; n++) {\r\n      if (data[n][1] !== null) {\r\n        len++;\r\n        sum[0] += data[n][0];\r\n        sum[1] += data[n][1];\r\n        sum[2] += data[n][0] * data[n][0];\r\n        sum[3] += data[n][0] * data[n][1];\r\n        sum[4] += data[n][1] * data[n][1];\r\n      }\r\n    }\r\n\r\n    const run = ((len * sum[2]) - (sum[0] * sum[0]));\r\n    const rise = ((len * sum[3]) - (sum[0] * sum[1]));\r\n    const gradient = run === 0 ? 0 : round(rise / run, options.precision);\r\n    const intercept = round((sum[1] / len) - ((gradient * sum[0]) / len), options.precision);\r\n\r\n    const predict = x => ([\r\n      round(x, options.precision),\r\n      round((gradient * x) + intercept, options.precision)]\r\n    );\r\n\r\n    const points = data.map(point => predict(point[0]));\r\n\r\n    return {\r\n      points,\r\n      predict,\r\n      equation: [gradient, intercept],\r\n      r2: round(determinationCoefficient(data, points), options.precision),\r\n      string: intercept === 0 ? `y = ${gradient}x` : `y = ${gradient}x + ${intercept}`,\r\n    };\r\n  },\r\n\r\n  exponential(data, options) {\r\n    const sum = [0, 0, 0, 0, 0, 0];\r\n\r\n    for (let n = 0; n < data.length; n++) {\r\n      if (data[n][1] !== null) {\r\n        sum[0] += data[n][0];\r\n        sum[1] += data[n][1];\r\n        sum[2] += data[n][0] * data[n][0] * data[n][1];\r\n        sum[3] += data[n][1] * Math.log(data[n][1]);\r\n        sum[4] += data[n][0] * data[n][1] * Math.log(data[n][1]);\r\n        sum[5] += data[n][0] * data[n][1];\r\n      }\r\n    }\r\n\r\n    const denominator = ((sum[1] * sum[2]) - (sum[5] * sum[5]));\r\n    const a = Math.exp(((sum[2] * sum[3]) - (sum[5] * sum[4])) / denominator);\r\n    const b = ((sum[1] * sum[4]) - (sum[5] * sum[3])) / denominator;\r\n    const coeffA = round(a, options.precision);\r\n    const coeffB = round(b, options.precision);\r\n    const predict = x => ([\r\n      round(x, options.precision),\r\n      round(coeffA * Math.exp(coeffB * x), options.precision),\r\n    ]);\r\n\r\n    const points = data.map(point => predict(point[0]));\r\n\r\n    return {\r\n      points,\r\n      predict,\r\n      equation: [coeffA, coeffB],\r\n      string: `y = ${coeffA}e^(${coeffB}x)`,\r\n      r2: round(determinationCoefficient(data, points), options.precision),\r\n    };\r\n  },\r\n\r\n  logarithmic(data, options) {\r\n    const sum = [0, 0, 0, 0];\r\n    const len = data.length;\r\n\r\n    for (let n = 0; n < len; n++) {\r\n      if (data[n][1] !== null) {\r\n        sum[0] += Math.log(data[n][0]);\r\n        sum[1] += data[n][1] * Math.log(data[n][0]);\r\n        sum[2] += data[n][1];\r\n        sum[3] += (Math.log(data[n][0]) ** 2);\r\n      }\r\n    }\r\n\r\n    const a = ((len * sum[1]) - (sum[2] * sum[0])) / ((len * sum[3]) - (sum[0] * sum[0]));\r\n    const coeffB = round(a, options.precision);\r\n    const coeffA = round((sum[2] - (coeffB * sum[0])) / len, options.precision);\r\n\r\n    const predict = x => ([\r\n      round(x, options.precision),\r\n      round(round(coeffA + (coeffB * Math.log(x)), options.precision), options.precision),\r\n    ]);\r\n\r\n    const points = data.map(point => predict(point[0]));\r\n\r\n    return {\r\n      points,\r\n      predict,\r\n      equation: [coeffA, coeffB],\r\n      string: `y = ${coeffA} + ${coeffB} ln(x)`,\r\n      r2: round(determinationCoefficient(data, points), options.precision),\r\n    };\r\n  },\r\n\r\n  power(data, options) {\r\n    const sum = [0, 0, 0, 0, 0];\r\n    const len = data.length;\r\n\r\n    for (let n = 0; n < len; n++) {\r\n      if (data[n][1] !== null) {\r\n        sum[0] += Math.log(data[n][0]);\r\n        sum[1] += Math.log(data[n][1]) * Math.log(data[n][0]);\r\n        sum[2] += Math.log(data[n][1]);\r\n        sum[3] += (Math.log(data[n][0]) ** 2);\r\n      }\r\n    }\r\n\r\n    const b = ((len * sum[1]) - (sum[0] * sum[2])) / ((len * sum[3]) - (sum[0] ** 2));\r\n    const a = ((sum[2] - (b * sum[0])) / len);\r\n    const coeffA = round(Math.exp(a), options.precision);\r\n    const coeffB = round(b, options.precision);\r\n\r\n    const predict = x => ([\r\n      round(x, options.precision),\r\n      round(round(coeffA * (x ** coeffB), options.precision), options.precision),\r\n    ]);\r\n\r\n    const points = data.map(point => predict(point[0]));\r\n\r\n    return {\r\n      points,\r\n      predict,\r\n      equation: [coeffA, coeffB],\r\n      string: `y = ${coeffA}x^${coeffB}`,\r\n      r2: round(determinationCoefficient(data, points), options.precision),\r\n    };\r\n  },\r\n\r\n  polynomial(data, options) {\r\n    const lhs = [];\r\n    const rhs = [];\r\n    let a = 0;\r\n    let b = 0;\r\n\r\n    const len = data.length;\r\n    const k = options.order + 1;\r\n\r\n    for (let i = 1; i < k; i++) {\r\n      for (let l = 0; l < len; l++) {\r\n        if (data[l][1] !== null) {\r\n          a += (data[l][0] ** i) * data[l][1];\r\n        }\r\n      }\r\n\r\n      lhs.push(a);\r\n      a = 0;\r\n\r\n      const c = [];\r\n      for (let j = 1; j < k; j++) {\r\n        for (let l = 0; l < len; l++) {\r\n          if (data[l][1] !== null) {\r\n            b += data[l][0] ** (i + j);\r\n          }\r\n        }\r\n        c.push(b);\r\n        b = 0;\r\n      }\r\n      rhs.push(c);\r\n    }\r\n    rhs.push(lhs);\r\n\r\n    const coefficients = [0,...gaussianElimination(rhs, k).map(v => round(v, options.precision))];\r\n    const predict = x => ([\r\n      round(x, options.precision),\r\n      round(\r\n        coefficients.reduce((sum, coeff, power) => sum + (coeff * (x ** power)), 0),\r\n        options.precision,\r\n      ),\r\n    ]);\r\n\r\n    const points = data.map(point => predict(point[0]));\r\n\r\n    let string = 'y = ';\r\n    for (let i = coefficients.length - 1; i >= 0; i--) {\r\n      if (i > 1) {\r\n        string += `${coefficients[i]}x^${i} + `;\r\n      } else if (i === 1) {\r\n        string += `${coefficients[i]}x + `;\r\n      } else {\r\n        string += coefficients[i];\r\n      }\r\n    }\r\n\r\n    return {\r\n      string,\r\n      points,\r\n      predict,\r\n      equation: [...coefficients].reverse(),\r\n      r2: round(determinationCoefficient(data, points), options.precision),\r\n    };\r\n  },\r\n};\r\n\r\nfunction createWrapper() {\r\n  const reduce = (accumulator, name) => ({\r\n    _round: round,\r\n    ...accumulator,\r\n    [name](data, supplied) {\r\n      return methods[name](data, {\r\n        ...DEFAULT_OPTIONS,\r\n        ...supplied,\r\n      });\r\n    },\r\n  });\r\n\r\n  return Object.keys(methods).reduce(reduce, {});\r\n}\r\n","E:\\Infiltrometer\\infiltrometer21\\src\\app\\soilTypes.js",[],{"ruleId":"102","severity":1,"message":"103","line":7,"column":31,"nodeType":"104","messageId":"105","endLine":7,"endColumn":54},{"ruleId":"102","severity":1,"message":"106","line":9,"column":3,"nodeType":"104","messageId":"105","endLine":9,"endColumn":28},{"ruleId":"102","severity":1,"message":"107","line":9,"column":30,"nodeType":"104","messageId":"105","endLine":9,"endColumn":56},{"ruleId":"102","severity":1,"message":"108","line":36,"column":12,"nodeType":"104","messageId":"105","endLine":36,"endColumn":33},{"ruleId":"102","severity":1,"message":"109","line":44,"column":12,"nodeType":"104","messageId":"105","endLine":44,"endColumn":36},{"ruleId":"102","severity":1,"message":"110","line":1,"column":10,"nodeType":"104","messageId":"105","endLine":1,"endColumn":26},{"ruleId":"111","replacedBy":"112"},{"ruleId":"113","replacedBy":"114"},{"ruleId":"102","severity":1,"message":"110","line":1,"column":10,"nodeType":"104","messageId":"105","endLine":1,"endColumn":26},{"ruleId":"102","severity":1,"message":"110","line":1,"column":10,"nodeType":"104","messageId":"105","endLine":1,"endColumn":26},{"ruleId":"102","severity":1,"message":"115","line":2,"column":9,"nodeType":"104","messageId":"105","endLine":2,"endColumn":25},{"ruleId":"102","severity":1,"message":"110","line":1,"column":10,"nodeType":"104","messageId":"105","endLine":1,"endColumn":26},{"ruleId":"102","severity":1,"message":"116","line":1,"column":17,"nodeType":"104","messageId":"105","endLine":1,"endColumn":25},{"ruleId":"102","severity":1,"message":"117","line":2,"column":23,"nodeType":"104","messageId":"105","endLine":2,"endColumn":34},{"ruleId":"102","severity":1,"message":"118","line":7,"column":10,"nodeType":"104","messageId":"105","endLine":7,"endColumn":22},{"ruleId":"102","severity":1,"message":"119","line":311,"column":10,"nodeType":"104","messageId":"105","endLine":311,"endColumn":23},"no-unused-vars","'selectInfiltrometerData' is defined but never used.","Identifier","unusedVar","'selectInfiltrometerRadius' is defined but never used.","'selectInfiltrometerSuction' is defined but never used.","'ValidateInitialVolume' is defined but never used.","'ValidateInfiltromterType' is defined but never used.","'createAsyncThunk' is defined but never used.","no-native-reassign",["120"],"no-negated-in-lhs",["121"],"'TimerStateValues' is defined but never used.","'useState' is defined but never used.","'useDispatch' is defined but never used.","'PrintReports' is defined but never used.","'createWrapper' is defined but never used.","no-global-assign","no-unsafe-negation"]